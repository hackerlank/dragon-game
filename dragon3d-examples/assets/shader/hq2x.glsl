// GLSL shader autogenerated by dragon3d_cg2glsl.py.
#if defined(VERTEX)
// glesv output by Cg compiler
// cgc version 3.1.0013, build date Apr 18 2012
// command line args: -profile glesv -quiet
//vendor NVIDIA Corporation
//version 3.1.0.13
//profile glesv
//program main_vertex
//semantic main_vertex.modelViewProj
//semantic main_vertex.IN
//var float4x4 modelViewProj :  : _modelViewProj1[0], 4 : 2 : 1
//var float2 IN.video_size :  :  : 6 : 0
//var float2 IN.texture_size :  : _IN1._texture_size : 6 : 1
//var float2 IN.output_size :  :  : 6 : 0
//var float4 position : $vin.POSITION : POSITION : 0 : 1
//var float4 oPosition : $vout.POSITION : HPOS : 1 : 1
//var float4 color : $vin.COLOR : COLOR : 3 : 1
//var float4 oColor : $vout.COLOR : COLOR : 4 : 1
//var float2 tex : $vin.TEXCOORD : TEXCOORD : 5 : 1
//var float2 coords.c00 : $vout._coords1._c00 : _coords1._c00 : 7 : 1
//var float2 coords.c01 : $vout._coords1._c01 : _coords1._c01 : 7 : 1
//var float2 coords.c02 : $vout._coords1._c02 : _coords1._c02 : 7 : 1
//var float2 coords.c10 : $vout._coords1._c10 : _coords1._c10 : 7 : 1
//var float2 coords.c11 : $vout._coords1._c11 : _coords1._c11 : 7 : 1
//var float2 coords.c12 : $vout._coords1._c12 : _coords1._c12 : 7 : 1
//var float2 coords.c20 : $vout._coords1._c20 : _coords1._c20 : 7 : 1
//var float2 coords.c21 : $vout._coords1._c21 : _coords1._c21 : 7 : 1
//var float2 coords.c22 : $vout._coords1._c22 : _coords1._c22 : 7 : 1

precision mediump float;

struct tex_coords {
    vec2 _c00;
    vec2 _c01;
    vec2 _c02;
    vec2 _c10;
    vec2 _c11;
    vec2 _c12;
    vec2 _c20;
    vec2 _c21;
    vec2 _c22;
};

struct input {
    vec2 _video_size;
    vec2 _texture_size;
    vec2 _output_size;
};

vec4 _oPosition1;
tex_coords _coords1;
uniform vec4 _modelViewProj1[4];
uniform input _IN1;
vec4 _r0012;
attribute vec4 POSITION;
attribute vec4 COLOR;
varying vec4 COL0;
attribute vec4 TEXCOORD0;

 // main procedure, the original name was main_vertex
void main()
{

    vec4 _oColor;
    vec2 _delta;
    tex_coords _TMP8;

    _r0012 = POSITION.x*_modelViewProj1[0];
    _r0012 = _r0012 + POSITION.y*_modelViewProj1[1];
    _r0012 = _r0012 + POSITION.z*_modelViewProj1[2];
    _r0012 = _r0012 + POSITION.w*_modelViewProj1[3];
    _oPosition1 = _r0012;
    _oColor = COLOR;
    _delta = 5.00000000E-01/_IN1._texture_size;
    _TMP8._c00 = TEXCOORD0.xy + vec2(-_delta.x, -_delta.y);
    _TMP8._c01 = TEXCOORD0.xy + vec2(-_delta.x, 0.00000000E+00);
    _TMP8._c02 = TEXCOORD0.xy + vec2(-_delta.x, _delta.y);
    _TMP8._c10 = TEXCOORD0.xy + vec2(0.00000000E+00, -_delta.y);
    _TMP8._c12 = TEXCOORD0.xy + vec2(0.00000000E+00, _delta.y);
    _TMP8._c20 = TEXCOORD0.xy + vec2(_delta.x, -_delta.y);
    _TMP8._c21 = TEXCOORD0.xy + vec2(_delta.x, 0.00000000E+00);
    _TMP8._c22 = TEXCOORD0.xy + vec2(_delta.x, _delta.y);
    _coords1._c00 = _TMP8._c00;
    _coords1._c01 = _TMP8._c01;
    _coords1._c02 = _TMP8._c02;
    _coords1._c10 = _TMP8._c10;
    _coords1._c11 = TEXCOORD0.xy;
    _coords1._c12 = _TMP8._c12;
    _coords1._c20 = _TMP8._c20;
    _coords1._c21 = _TMP8._c21;
    _coords1._c22 = _TMP8._c22;
    gl_Position = _r0012;
    COL0 = COLOR;
} // main end

#elif defined(FRAGMENT)
// glesf output by Cg compiler
// cgc version 3.1.0013, build date Apr 18 2012
// command line args: -profile glesf -quiet
//vendor NVIDIA Corporation
//version 3.1.0.13
//profile glesf
//program main_fragment
//semantic main_fragment.s0 : TEXUNIT0
//var sampler2D s0 : TEXUNIT0 : _s01 0 : 1 : 1
//var float2 co.c00 : $vin._co1._c001 : _co1._c001 : 0 : 1
//var float2 co.c01 : $vin._co1._c011 : _co1._c011 : 0 : 1
//var float2 co.c02 : $vin._co1._c021 : _co1._c021 : 0 : 1
//var float2 co.c10 : $vin._co1._c101 : _co1._c101 : 0 : 1
//var float2 co.c11 : $vin._co1._c111 : _co1._c111 : 0 : 1
//var float2 co.c12 : $vin._co1._c121 : _co1._c121 : 0 : 1
//var float2 co.c20 : $vin._co1._c201 : _co1._c201 : 0 : 1
//var float2 co.c21 : $vin._co1._c211 : _co1._c211 : 0 : 1
//var float2 co.c22 : $vin._co1._c221 : _co1._c221 : 0 : 1
//var float4 main_fragment : $vout.COLOR : COL : -1 : 1

precision mediump float;

struct tex_coords {
    vec2 _c001;
    vec2 _c011;
    vec2 _c021;
    vec2 _c101;
    vec2 _c111;
    vec2 _c121;
    vec2 _c201;
    vec2 _c211;
    vec2 _c221;
};

struct input {
    vec2 _video_size;
    vec2 _texture_size;
    vec2 _output_size;
};

vec4 _ret_0;
float _TMP29;
float _TMP30;
vec3 _TMP28;
float _TMP27;
vec3 _TMP26;
float _TMP25;
vec3 _TMP24;
float _TMP23;
vec3 _TMP22;
float _TMP21;
float _TMP20;
float _TMP19;
float _TMP18;
vec3 _TMP17;
float _TMP16;
vec3 _TMP15;
float _TMP14;
vec3 _TMP13;
float _TMP12;
vec3 _TMP11;
vec3 _TMP10;
vec3 _TMP9;
vec4 _TMP8;
vec4 _TMP7;
vec4 _TMP6;
vec4 _TMP5;
vec4 _TMP4;
vec4 _TMP3;
vec4 _TMP2;
vec4 _TMP1;
vec4 _TMP0;
tex_coords _co1;
uniform sampler2D _s01;
vec3 _a0058;
vec3 _a0062;
vec3 _a0066;
vec3 _a0070;
vec3 _a0074;
vec3 _a0078;
vec3 _a0084;
vec3 _a0086;
vec3 _a0088;
float _TMP91;
float _x0092;
vec3 _a0098;
float _TMP101;
float _x0102;
vec3 _a0108;
float _TMP111;
float _x0112;
vec3 _a0118;
float _TMP121;
float _x0122;

 // main procedure, the original name was main_fragment
void main()
{

    vec3 _c11;
    float _md1;
    float _md2;
    float _w1;
    float _w2;
    float _w3;
    float _w4;
    float _t1;
    float _t2;
    float _ww;
    float _lc1;
    float _lc2;
    vec3 _TMP38;

    _TMP0 = texture2D(_s01, _co1._c001);
    _TMP1 = texture2D(_s01, _co1._c011);
    _TMP2 = texture2D(_s01, _co1._c021);
    _TMP3 = texture2D(_s01, _co1._c101);
    _TMP4 = texture2D(_s01, _co1._c111);
    _TMP5 = texture2D(_s01, _co1._c121);
    _TMP6 = texture2D(_s01, _co1._c201);
    _TMP7 = texture2D(_s01, _co1._c211);
    _TMP8 = texture2D(_s01, _co1._c221);
    _a0058 = _TMP0.xyz - _TMP8.xyz;
    _TMP9 = abs(_a0058);
    _md1 = dot(_TMP9, vec3( 1.00000000E+00, 1.00000000E+00, 1.00000000E+00));
    _a0062 = _TMP2.xyz - _TMP6.xyz;
    _TMP10 = abs(_a0062);
    _md2 = dot(_TMP10, vec3( 1.00000000E+00, 1.00000000E+00, 1.00000000E+00));
    _a0066 = _TMP8.xyz - _TMP4.xyz;
    _TMP11 = abs(_a0066);
    _TMP12 = dot(_TMP11, vec3( 1.00000000E+00, 1.00000000E+00, 1.00000000E+00));
    _w1 = _TMP12*_md2;
    _a0070 = _TMP2.xyz - _TMP4.xyz;
    _TMP13 = abs(_a0070);
    _TMP14 = dot(_TMP13, vec3( 1.00000000E+00, 1.00000000E+00, 1.00000000E+00));
    _w2 = _TMP14*_md1;
    _a0074 = _TMP0.xyz - _TMP4.xyz;
    _TMP15 = abs(_a0074);
    _TMP16 = dot(_TMP15, vec3( 1.00000000E+00, 1.00000000E+00, 1.00000000E+00));
    _w3 = _TMP16*_md2;
    _a0078 = _TMP6.xyz - _TMP4.xyz;
    _TMP17 = abs(_a0078);
    _TMP18 = dot(_TMP17, vec3( 1.00000000E+00, 1.00000000E+00, 1.00000000E+00));
    _w4 = _TMP18*_md1;
    _t1 = _w1 + _w3;
    _t2 = _w2 + _w4;
    _TMP19 = max(_t1, _t2);
    _ww = _TMP19 + 9.99999975E-05;
    _c11 = (_w1*_TMP0.xyz + _w2*_TMP6.xyz + _w3*_TMP8.xyz + _w4*_TMP2.xyz + _ww*_TMP4.xyz)/(_t1 + _t2 + _ww);
    _a0084 = _TMP3.xyz + _TMP5.xyz + _c11;
    _TMP20 = dot(_a0084, vec3( 1.00000000E+00, 1.00000000E+00, 1.00000000E+00));
    _lc1 = -2.50000000E-01/(1.19999997E-01*_TMP20 + 2.50000000E-01);
    _a0086 = _TMP1.xyz + _TMP7.xyz + _c11;
    _TMP21 = dot(_a0086, vec3( 1.00000000E+00, 1.00000000E+00, 1.00000000E+00));
    _lc2 = -2.50000000E-01/(1.19999997E-01*_TMP21 + 2.50000000E-01);
    _a0088 = _c11 - _TMP3.xyz;
    _TMP22 = abs(_a0088);
    _TMP23 = dot(_TMP22, vec3( 1.00000000E+00, 1.00000000E+00, 1.00000000E+00));
    _x0092 = _lc1*_TMP23 + 3.24999988E-01;
    _TMP30 = min(2.50000000E-01, _x0092);
    _TMP91 = max(-5.00000007E-02, _TMP30);
    _a0098 = _c11 - _TMP7.xyz;
    _TMP24 = abs(_a0098);
    _TMP25 = dot(_TMP24, vec3( 1.00000000E+00, 1.00000000E+00, 1.00000000E+00));
    _x0102 = _lc2*_TMP25 + 3.24999988E-01;
    _TMP30 = min(2.50000000E-01, _x0102);
    _TMP101 = max(-5.00000007E-02, _TMP30);
    _a0108 = _c11 - _TMP5.xyz;
    _TMP26 = abs(_a0108);
    _TMP27 = dot(_TMP26, vec3( 1.00000000E+00, 1.00000000E+00, 1.00000000E+00));
    _x0112 = _lc1*_TMP27 + 3.24999988E-01;
    _TMP30 = min(2.50000000E-01, _x0112);
    _TMP111 = max(-5.00000007E-02, _TMP30);
    _a0118 = _c11 - _TMP1.xyz;
    _TMP28 = abs(_a0118);
    _TMP29 = dot(_TMP28, vec3( 1.00000000E+00, 1.00000000E+00, 1.00000000E+00));
    _x0122 = _lc2*_TMP29 + 3.24999988E-01;
    _TMP30 = min(2.50000000E-01, _x0122);
    _TMP121 = max(-5.00000007E-02, _TMP30);
    _TMP38 = _TMP91*_TMP3.xyz + _TMP101*_TMP7.xyz + _TMP111*_TMP5.xyz + _TMP121*_TMP1.xyz + ((((1.00000000E+00 - _TMP91) - _TMP101) - _TMP111) - _TMP121)*_c11;
    _ret_0 = vec4(_TMP38.x, _TMP38.y, _TMP38.z, 1.00000000E+00);
    gl_FragColor = _ret_0;
    return;
} // main end

#endif
